<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pathex.managing.synchronizer &mdash; PathEx 0.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> PathEx
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generalities/index.html">Generalities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../semantics/index.html">Semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../API/pathex.html">pathex package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PathEx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>pathex.managing.synchronizer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pathex.managing.synchronizer</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">threading</span>

<span class="kn">from</span> <span class="nn">pathex.adts.concurrency.counted_condition</span> <span class="kn">import</span> <span class="n">CountedCondition</span>
<span class="kn">from</span> <span class="nn">pathex.expressions.expression</span> <span class="kn">import</span> <span class="n">Expression</span>
<span class="kn">from</span> <span class="nn">pathex.machines.decomposers.decomposer</span> <span class="kn">import</span> <span class="n">DecomposerMatch</span>
<span class="kn">from</span> <span class="nn">pathex.managing.manager</span> <span class="kn">import</span> <span class="n">Manager</span>
<span class="kn">from</span> <span class="nn">pathex.managing.mixins</span> <span class="kn">import</span> <span class="n">LogbookMixin</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Synchronizer&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">LabelInfo</span><span class="p">(</span><span class="n">CountedCondition</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_requests</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_permits</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">get_requests</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_requests</span>

    <span class="k">def</span> <span class="nf">get_permits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_permits</span>

    <span class="k">def</span> <span class="nf">inc_requests</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_requests</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">inc_permits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_permits</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">notify</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_permits</span> <span class="o">+=</span> <span class="mi">1</span>


<div class="viewcode-block" id="Synchronizer"><a class="viewcode-back" href="../../../API/pathex.managing.synchronizer.html#pathex.managing.synchronizer.Synchronizer">[docs]</a><span class="k">class</span> <span class="nc">Synchronizer</span><span class="p">(</span><span class="n">Manager</span><span class="p">,</span> <span class="n">LogbookMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class is a manager that controls the execution of its registered threads.</span>

<span class="sd">    Example using :meth:`match`::</span>

<span class="sd">        &gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor</span>
<span class="sd">        &gt;&gt;&gt; from pathex import Synchronizer, Concatenation as C</span>

<span class="sd">        &gt;&gt;&gt; # The following expression generates &#39;PiPfCiCf&#39; | &#39;PiPfCiCfPiPfCiCf&#39; | ...</span>
<span class="sd">        &gt;&gt;&gt; exp = +C(&#39;Pi&#39;,&#39;Pf&#39;,&#39;Ci&#39;,&#39;Cf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sync = Synchronizer(exp)</span>
<span class="sd">        &gt;&gt;&gt; produced = []</span>
<span class="sd">        &gt;&gt;&gt; consumed = []</span>

<span class="sd">        &gt;&gt;&gt; def producer(x):</span>
<span class="sd">        ...     sync.match(&#39;Pi&#39;)</span>
<span class="sd">        ...     produced.append(x)</span>
<span class="sd">        ...     sync.match(&#39;Pf&#39;)</span>

<span class="sd">        &gt;&gt;&gt; def consumer():</span>
<span class="sd">        ...     sync.match(&#39;Ci&#39;)</span>
<span class="sd">        ...     consumed.append(produced.pop())</span>
<span class="sd">        ...     sync.match(&#39;Cf&#39;)</span>

<span class="sd">        &gt;&gt;&gt; with ThreadPoolExecutor(max_workers=8) as executor:</span>
<span class="sd">        ...     for _ in range(4):</span>
<span class="sd">        ...         _ = executor.submit(consumer)</span>
<span class="sd">        ...     for i in range(4):</span>
<span class="sd">        ...         _ = executor.submit(producer, i)</span>

<span class="sd">        &gt;&gt;&gt; assert produced == []</span>
<span class="sd">        &gt;&gt;&gt; assert set(consumed) == {0, 1, 2, 3}</span>
<span class="sd">        &gt;&gt;&gt; assert sync.requests(&#39;Pi&#39;) == sync.permits(&#39;Pf&#39;) == sync.requests(&#39;Ci&#39;) == sync.permits(&#39;Cf&#39;) == 4</span>
<span class="sd">        &gt;&gt;&gt; assert sync.permits(&#39;WrongTag&#39;) == sync.requests(&#39;WrongTag&#39;) == 0</span>

<span class="sd">    Example using :meth:`region` as a context manager::</span>

<span class="sd">        &gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor</span>
<span class="sd">        &gt;&gt;&gt; from pathex import Synchronizer, Tag</span>

<span class="sd">        &gt;&gt;&gt; a, b, c = Tag.named(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span>

<span class="sd">        &gt;&gt;&gt; exp = ( a + (b|c) )+2</span>

<span class="sd">        &gt;&gt;&gt; shared_list = []</span>

<span class="sd">        &gt;&gt;&gt; sync = Synchronizer(exp)</span>

<span class="sd">        &gt;&gt;&gt; def func_a():</span>
<span class="sd">        ...     with sync.region(a):</span>
<span class="sd">        ...         shared_list.append(a.enter)</span>
<span class="sd">        ...         # print(&#39;Func a&#39;)</span>
<span class="sd">        ...         shared_list.append(a.exit)</span>

<span class="sd">        &gt;&gt;&gt; def func_b():</span>
<span class="sd">        ...     with sync.region(b):</span>
<span class="sd">        ...         shared_list.append(b.enter)</span>
<span class="sd">        ...         # print(&#39;Func b&#39;)</span>
<span class="sd">        ...         shared_list.append(b.exit)</span>

<span class="sd">        &gt;&gt;&gt; def func_c():</span>
<span class="sd">        ...     with sync.region(c):</span>
<span class="sd">        ...         shared_list.append(c.enter)</span>
<span class="sd">        ...         # print(&#39;Func c&#39;)</span>
<span class="sd">        ...         shared_list.append(c.exit)</span>

<span class="sd">        &gt;&gt;&gt; with ThreadPoolExecutor(max_workers=4) as executor:</span>
<span class="sd">        ...     _ = executor.submit(func_c)</span>
<span class="sd">        ...     _ = executor.submit(func_a)</span>
<span class="sd">        ...     _ = executor.submit(func_b)</span>
<span class="sd">        ...     _ = executor.submit(func_a)</span>

<span class="sd">        &gt;&gt;&gt; from pathex.adts.util import SET_OF_TUPLES</span>
<span class="sd">        &gt;&gt;&gt; allowed_paths = exp.get_language(SET_OF_TUPLES)</span>

<span class="sd">        &gt;&gt;&gt; assert tuple(shared_list) in allowed_paths</span>

<span class="sd">    Example using :meth:`region` as a function decorator::</span>

<span class="sd">        &gt;&gt;&gt; a, b, c = Tag.anonym(3)</span>

<span class="sd">        &gt;&gt;&gt; exp = ( a + (b|c) )+2</span>

<span class="sd">        &gt;&gt;&gt; shared_list = []</span>

<span class="sd">        &gt;&gt;&gt; sync = Synchronizer(exp)</span>

<span class="sd">        &gt;&gt;&gt; @sync.region(a)</span>
<span class="sd">        ... def func_a():</span>
<span class="sd">        ...     shared_list.append(a.enter)</span>
<span class="sd">        ...     # print(&#39;Func a&#39;)</span>
<span class="sd">        ...     shared_list.append(a.exit)</span>

<span class="sd">        &gt;&gt;&gt; @sync.region(b)</span>
<span class="sd">        ... def func_b():</span>
<span class="sd">        ...     shared_list.append(b.enter)</span>
<span class="sd">        ...     # print(&#39;Func b&#39;)</span>
<span class="sd">        ...     shared_list.append(b.exit)</span>

<span class="sd">        &gt;&gt;&gt; def func_c():</span>
<span class="sd">        ...     shared_list.append(c.enter)</span>
<span class="sd">        ...     # print(&#39;Func c&#39;)</span>
<span class="sd">        ...     shared_list.append(c.exit)</span>

<span class="sd">        &gt;&gt;&gt; # Another way of applying decoration</span>
<span class="sd">        &gt;&gt;&gt; func_c = sync.region(c)(func_c)</span>

<span class="sd">        &gt;&gt;&gt; with ThreadPoolExecutor(max_workers=4) as executor:</span>
<span class="sd">        ...     _ = executor.submit(func_c)</span>
<span class="sd">        ...     _ = executor.submit(func_a)</span>
<span class="sd">        ...     _ = executor.submit(func_b)</span>
<span class="sd">        ...     _ = executor.submit(func_a)</span>

<span class="sd">        &gt;&gt;&gt; from pathex.adts.util import SET_OF_TUPLES</span>
<span class="sd">        &gt;&gt;&gt; allowed_paths = exp.get_language(SET_OF_TUPLES)</span>

<span class="sd">        &gt;&gt;&gt; assert tuple(shared_list) in allowed_paths</span>

<span class="sd">    Example using :meth:`region` as a method decorator::</span>

<span class="sd">        &gt;&gt;&gt; from collections.abc import Iterable</span>

<span class="sd">        &gt;&gt;&gt; class SharedList:</span>
<span class="sd">        ...     # expression and synchronizer may be defined</span>
<span class="sd">        ...     # outside the class if necessary. Here, it are</span>
<span class="sd">        ...     # inside the class just for convenience.</span>
<span class="sd">        ...     a, b, c = Tag.anonym(3)</span>
<span class="sd">        ...     exp = ( a + (b|c) )+2</span>
<span class="sd">        ...     sync = Synchronizer(exp)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         self._l = []</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def __iter__(self):</span>
<span class="sd">        ...         return iter(self._l)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     @sync.region(a)</span>
<span class="sd">        ...     def func_a(self):</span>
<span class="sd">        ...         self._l.append(self.a.enter)</span>
<span class="sd">        ...         # print(&#39;Func a&#39;)</span>
<span class="sd">        ...         self._l.append(self.a.exit)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     @sync.region(b)</span>
<span class="sd">        ...     def func_b(self):</span>
<span class="sd">        ...         self._l.append(self.b.enter)</span>
<span class="sd">        ...         # print(&#39;Func b&#39;)</span>
<span class="sd">        ...         self._l.append(self.b.exit)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def func_c(self):</span>
<span class="sd">        ...         self._l.append(self.c.enter)</span>
<span class="sd">        ...         # print(&#39;Func c&#39;)</span>
<span class="sd">        ...         self._l.append(self.c.exit)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     # Another way of applying decoration</span>
<span class="sd">        ...     func_c = sync.region(c)(func_c)</span>

<span class="sd">        &gt;&gt;&gt; shared = SharedList()</span>
<span class="sd">        &gt;&gt;&gt; with ThreadPoolExecutor(max_workers=4) as executor:</span>
<span class="sd">        ...     _ = executor.submit(shared.func_c)</span>
<span class="sd">        ...     _ = executor.submit(shared.func_a)</span>
<span class="sd">        ...     _ = executor.submit(shared.func_b)</span>
<span class="sd">        ...     _ = executor.submit(shared.func_a)</span>

<span class="sd">        &gt;&gt;&gt; from pathex.adts.util import SET_OF_TUPLES</span>
<span class="sd">        &gt;&gt;&gt; allowed_paths = shared.exp.get_language(SET_OF_TUPLES)</span>

<span class="sd">        &gt;&gt;&gt; assert tuple(shared) in allowed_paths</span>

<span class="sd">    Example of *readers* and *writers* threads:</span>

<span class="sd">        &gt;&gt;&gt; from collections import deque</span>
<span class="sd">        &gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor</span>
<span class="sd">        &gt;&gt;&gt; from pathex import Synchronizer, Tag</span>

<span class="sd">        &gt;&gt;&gt; writer, reader = Tag.named(&#39;writer&#39;, &#39;reader&#39;)</span>

<span class="sd">        &gt;&gt;&gt; exp = (writer | reader//...)+...</span>

<span class="sd">        &gt;&gt;&gt; sync = Synchronizer(exp)</span>

<span class="sd">        &gt;&gt;&gt; shared_buffer = deque()</span>

<span class="sd">        &gt;&gt;&gt; @sync.region(writer)</span>
<span class="sd">        ... def append(x):</span>
<span class="sd">        ...     shared_buffer.append(x)</span>

<span class="sd">        &gt;&gt;&gt; @sync.region(reader)</span>
<span class="sd">        ... def get_top():</span>
<span class="sd">        ...     try:</span>
<span class="sd">        ...         x = shared_buffer[0]</span>
<span class="sd">        ...     except Exception:</span>
<span class="sd">        ...         return None</span>
<span class="sd">        ...     else:</span>
<span class="sd">        ...         return x</span>

<span class="sd">        &gt;&gt;&gt; @sync.region(writer)</span>
<span class="sd">        ... def appendleft(x):</span>
<span class="sd">        ...     shared_buffer.appendleft(x)</span>

<span class="sd">        &gt;&gt;&gt; with ThreadPoolExecutor() as executor:</span>
<span class="sd">        ...     _ = [executor.submit(append, 4) for _ in range(5)]</span>
<span class="sd">        ...     _ = [executor.submit(get_top) for _ in range(5)]</span>
<span class="sd">        ...     _ = [executor.submit(appendleft, 3) for _ in range(5)]</span>

<span class="sd">        &gt;&gt;&gt; assert shared_buffer == deque([3, 3, 3, 3, 3, 4, 4, 4, 4, 4])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exp</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span>
                 <span class="n">decomposer</span><span class="p">:</span> <span class="n">DecomposerMatch</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">lock_class</span><span class="o">=</span><span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock_class</span> <span class="o">=</span> <span class="n">lock_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_lock</span> <span class="o">=</span> <span class="n">lock_class</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="n">LabelInfo</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">Manager</span><span class="o">.</span><span class="n">match</span>
    <span class="sd">&quot;&quot;&quot;This method is used to wait for the availability of a single label.</span>

<span class="sd">    If the expression of the synchronizer is not able to generate the given object then the execution is blocked until the presence of another label in another task advances the associated expression&#39;s automata, so it can generate the label given in this method.</span>

<span class="sd">    The direct use of this method should be exercised with caution, because it leads to non structured code. In fact, in an object oriented design, its use should be discouraged. This method is public just because it might be usefull in a very specific and extraordinary use case where an structured approach may be too expensive, harder to design or to maintain.</span>

<span class="sd">    For an structured approach use the decorator :meth:`register` or the context manager :meth:`region`.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (object): The label to wait for.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_when_requested_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>  <span class="c1"># protect the entire procedure</span>
        <span class="n">label_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">label</span><span class="p">,</span> <span class="n">LabelInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lock_class</span><span class="p">()))</span>
        <span class="n">label_info</span><span class="o">.</span><span class="n">inc_requests</span><span class="p">()</span>
        <span class="c1"># print(f&#39;requested {label}&#39;)</span>
        <span class="k">return</span> <span class="n">label_info</span>

    <span class="k">def</span> <span class="nf">_when_matched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">label_info</span><span class="p">:</span> <span class="n">LabelInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># print(f&#39;matched {label}&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_waiting_labels</span><span class="p">()</span>
        <span class="n">label_info</span><span class="o">.</span><span class="n">inc_permits</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_when_not_matched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">label_info</span><span class="p">:</span> <span class="n">LabelInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># print(f&#39;not_matched {label}&#39;)</span>
        <span class="c1"># release the procedure&#39;s protection lock in order to get blocked in the following line, so the blocking will be because this task being waiting for some other task, not because of the procedure&#39;s protection lock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

        <span class="c1"># lock.acquire in order to block.</span>
        <span class="c1"># lock.release must be done by another task.</span>
        <span class="k">with</span> <span class="n">label_info</span><span class="p">:</span>
            <span class="n">label_info</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_check_waiting_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">:</span>
                <span class="n">lock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">lock</span><span class="o">.</span><span class="n">waiting_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                            <span class="c1"># print(f&#39;releasing {label}&#39;)</span>
                            <span class="n">lock</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
                            <span class="c1"># print(f&#39;{label} released&#39;)</span>
                            <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

<div class="viewcode-block" id="Synchronizer.requests"><a class="viewcode-back" href="../../../API/pathex.managing.synchronizer.html#pathex.managing.synchronizer.Synchronizer.requests">[docs]</a>    <span class="k">def</span> <span class="nf">requests</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sync_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label_info</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">label_info</span><span class="o">.</span><span class="n">get_requests</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Synchronizer.permits"><a class="viewcode-back" href="../../../API/pathex.managing.synchronizer.html#pathex.managing.synchronizer.Synchronizer.permits">[docs]</a>    <span class="k">def</span> <span class="nf">permits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sync_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label_info</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">label_info</span><span class="o">.</span><span class="n">get_permits</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2021, Ernesto Soto GÃ³mez.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>