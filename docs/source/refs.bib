
@inproceedings{campbell_specification_1974,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {The specification of process synchronization by path expressions},
	isbn = {978-3-540-37805-1},
	doi = {10.1007/BFb0029355},
	abstract = {A new method of expressing synchronization is presented and the motivations and considerations which led to this method are explained. Synchronization rules, given by ‘path expressions’, are incorporated into the type definitions which are used to introduce data objects shared by several asynchronous processes. It is shown that the method's ability to express synchronization rules is equivalent to that of P and V operations, and a means of automatically translating path expressions to existing primitive synchronization operations is given.},
	booktitle = {Operating {Systems}},
	publisher = {Springer International Publishing},
	author = {Campbell, R. H. and Habermann, A. N.},
	editor = {Gelenbe, E. and Kaiser, C.},
	year = {1974},
	keywords = {Finite State Machine, Synchronization Method, Synchronization Problem, Synchronization Scheme, Type Definition},
	pages = {89--102},
	file = {(1974) - The Specification of Process Synchronization Path Expressions.pdf:/zfiles/documentation/categorized/2 - completely read/Computing/Concurrency/synchronization/path expressions/(1974) - The Specification of Process Synchronization by Path Expressions.pdf:application/pdf},
}

@inproceedings{heinlein_workflow_2001,
	title = {Workflow and process synchronization with interaction expressions and graphs},
	doi = {10.1109/ICDE.2001.914835},
	abstract = {Current workflow management technology does not provide adequate means for inter-workflow coordination as concurrently executing workflows are considered completely independent. While this simplified view might suffice for one application domain or the other, there are many real-world application scenarios where workflows, though independently modeled in order to remain comprehensible and manageable, are semantically interrelated. As pragmatical approaches, like merging interdependent workflows or inter-workflow message passing, do not satisfactorily solve the inter-workflow coordination problem, interaction expressions and graphs are proposed as a simple yet powerful formalism for the specification and implementation of synchronization conditions in general and inter-workflow dependencies in particular. In addition to a graph based semi-formal interpretation of the formalism, a precise formal semantics, an equivalent operational semantics, an efficient implementation of the latter, and detailed complexity analyses have been developed, allowing the formalism to be actually applied to solve real-world problems like inter-workflow coordination.},
	booktitle = {Proceedings 17th {International} {Conference} on {Data} {Engineering}},
	author = {Heinlein, C.},
	month = apr,
	year = {2001},
	keywords = {graph theory, formal specification, message passing, process synchronization, application domain, complexity analyses, concurrently executing workflows, Databases, Endoscopes, graph based semi-formal interpretation, inter-workflow coordination, inter-workflow dependencies, inter-workflow message passing, interaction expressions, interdependent workflows, Management information systems, Merging, Message passing, operational semantics, pragmatical approaches, precise formal semantics, programming language semantics, Prototypes, real-world application scenarios, real-world problems, synchronization conditions, Technology management, Ultrasonography, workflow management software, Workflow management software, workflow management technology, Writing},
	pages = {243--252},
	file = {(2001) - Workflow and process synchronization with interaction expressions and graphs - Heinlein, C - Proceedings 17th International Conference on Data Engineering.pdf:/zfiles/documentation/Concurrency/synchronization/dependency and data flow analysis/(2001) - Workflow and process synchronization with interaction expressions and graphs - Heinlein, C - Proceedings 17th International Conference on Data Engineering.pdf:application/pdf},
}

@phdthesis{campbell_path_1976,
	type = {Ph.{D}. {Thesis}},
	title = {Path expressions: a technique for specifying process synchronization},
	shorttitle = {Path expressions},
	url = {http://theses.ncl.ac.uk/jspui/handle/10443/1973},
	abstract = {Path expressions are a new method of describing synchronization which provides a clear and structured approach to the description of shared data and the co-ordination and communication between concurrent processes. This method is flexible in its ability to express synchronization, and may be used in differing forms, some equivalent to P,V operations on counting semaphores. This method of synchronization is presented, and the motivations and considerations from which it is derived are explained. A method for formally characterizing path expressions is given, together with several automatic means of translating path expressions into implementations using existing synchronization operations.},
	school = {Newcastle University},
	author = {Campbell, Roy H.},
	year = {1976},
	file = {(1976) - Path expressions. A technique for specifying process synchronization.pdf:/zfiles/documentation/categorized/2 - completely read/Computing/Concurrency/synchronization/path expressions/(1976) - Path expressions. A technique for specifying process synchronization.pdf:application/pdf},
}

@inproceedings{andler_predicate_1979,
	address = {San Antonio, Texas},
	series = {{POPL} '79},
	title = {Predicate {Path} {Expressions}},
	doi = {10.1145/567752.567774},
	abstract = {Path expressions are a tool for synchronization of concurrent processes. They are an integral part of the data abstraction mechanism in a programming language, and specify synchronization entirely in terms of the allowable sequences of operations on an object of the abstract data type. This paper describes an attempt to push the path expression synchronization construct along three dimensions - specification, verification, and implementation - into a useful theoretical and practical tool. We define Predicate Path Expressions (PPEs), which allow for a more convenient specification of many synchronization problems. The predicate is a powerful extension to path expressions that increases their expressiveness. We formally define the semantics of PPEs by a transformation to a corresponding nondeterministic program, thus allowing the use of known verification techniques for nondeterministic programs to be used for proving properties of the PPE and the data abstraction of which it is a part. We also describe our existing implementation, in Algol 68, of a data abstraction mechanism that incorporates PPEs.},
	booktitle = {Proceedings of the 6th {ACM} {SIGACT}-{SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Andler, Sten},
	year = {1979},
	pages = {226--236},
	file = {(1979) - Predicate path expressions. - Andler, S. - Proceedings of the 6th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages.pdf:/zfiles/documentation/categorized/2 - completely read/Computing/Concurrency/synchronization/path expressions/(1979) - Predicate path expressions. - Andler, S. - Proceedings of the 6th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages.pdf:application/pdf},
}

@article{bruegge_generalized_1983,
	title = {Generalized path expressions: {A} high-level debugging mechanism},
	volume = {3},
	issn = {0164-1212},
	shorttitle = {Generalized path expressions},
	url = {http://www.sciencedirect.com/science/article/pii/0164121283900122},
	doi = {10.1016/0164-1212(83)90012-2},
	abstract = {This paper introduces a modified version of path expressions called Path Rules which can be used as a debugging mechanism to monitor the dynamic behavior of a computation. Path rules have been implemented in a remote symbolic debugger running on the Three Rivers Computer Corporation PERQ computer under the Accent operating system.},
	number = {4},
	journal = {Journal of Systems and Software},
	author = {Bruegge, Bernd and Hibbard, Peter},
	month = dec,
	year = {1983},
	pages = {265--276},
	file = {(1983) - Generalized path expressions. A high-level debugging mechanism. - Bruegge, B., & Hibbard, P. - Journal of Systems and Software, 3(4), 265–276.pdf:/zfiles/documentation/Concurrency/synchronization/path expressions/(1983) - Generalized path expressions. A high-level debugging mechanism. - Bruegge, B., & Hibbard, P. - Journal of Systems and Software, 3(4), 265–276.pdf:application/pdf},
}

@techreport{habermann_path_1975,
	type = {Technical {Report}},
	title = {Path {Expressions}},
	url = {https://apps.dtic.mil/docs/citations/ADA015842},
	abstract = {Traditionally, synchronization of concurrent processes is coded in line by operations on semaphores or similar objects. Path expressions move the responsibility of implementing such restrictions from the programmer to a compiler. The programmer specifies as part of a type definition which execution sequences are permitted. The advantage of using path experssions instead of P, V operations on semaphores (or similar operations) is comparable to the advantage of using for- and while-statements instead of JUMP or BRANCH instructions. In this paper the rules for writing a path expression are described, parsing and implementation are discussed and the use of path expressions is shown by a number of examples.},
	institution = {Carnegie-Mellon University},
	author = {Habermann, A. N.},
	month = jun,
	year = {1975},
	file = {(1975) - Path expressions - Habermann, A. Nico.pdf:/zfiles/documentation/categorized/2 - completely read/Computing/Concurrency/synchronization/path expressions/(1975) - Path expressions - Habermann, A. Nico.pdf:application/pdf},
}

@article{hoepner_synchronizing_1992,
	title = {Synchronizing the presentation of multimedia objects},
	volume = {15},
	issn = {0140-3664},
	doi = {10.1016/0140-3664(92)90053-H},
	abstract = {The presentation of multimedia objects requires simultaneous and/or sequential presentation of several representation types (text, graphics, images, audio and video sequences). Therefore the presentation has to be structured and the temporal relations of different actions have to be described. The temporal relations are realized by applying synchronization mechanisms. In this paper a general synchronization model for the description of presentation sequences of multimedia objects is introduced. This model is visualized by Petri nets and examples are presented; it is also applied to the Open Document Architecture (ODA) standard, and ODA extensions are proposed to integrate temporal relationships into ODA.},
	number = {9},
	journal = {Computer Communications},
	author = {Hoepner, Petra},
	month = nov,
	year = {1992},
	keywords = {synchronization, multimedia objects, ODA extensions, presentation, temporal relations},
	pages = {557--564},
	file = {(1992) - Synchronizing the presentation of multimedia objects - Hoepner, P. - Computer Communications, 15(9), 557–564.pdf:/zfiles/documentation/categorized/2 - completely read/Computing/Concurrency/synchronization/path expressions/(1992) - Synchronizing the presentation of multimedia objects - Hoepner, P. - Computer Communications, 15(9), 557–564.pdf:application/pdf},
}

@phdthesis{headington_open_1984,
	address = {Iowa, EEUU},
	type = {Ph.{D}. {Thesis}},
	title = {Open predicate path expressions for distributed environments: notation, implementation, and extensions},
	copyright = {Copyright © Mark Roger Headington 1984},
	shorttitle = {Open predicate path expressions for distributed environments},
	abstract = {This dissertation introduces "open predicate path expressions"--a non-procedural, very-high-level language notation for the synchronization of concurrent accesses to shared data in distributed computer systems. The target environment is one in which "resource modules" (totally encapsulated instances of abstract data types) are the basic building blocks in a network of conventional, von Neumann computers or of functional, highly parallel machines. Each resource module will contain two independent submodules: a synchronization submodule which coordinates requests for access to the resource's data and an access-mechanism submodule which localizes the code for operations on that data;Open predicate path expressions are proposed as a specification language for the synchronization submodule and represent a blend of two existing path notations: open path expressions and predicate path expressions. Motivations for the adoption of this new notation are presented, and an implementation semantics for the notation is presented in the form of dataflow graphs;An algorithm is presented which will automatically synthesize an open predicate path expression into a dataflow graph, which is then implemented by a network of communicating submodules written in either a sequential or an applicative language. Finally, an extended notation for the synchronization submodule is proposed, the purpose of which is to provide greater expressive power for certain synchronization problems which are difficult to specify using path expressions alone.},
	school = {Iowa State University},
	author = {Headington, Mark},
	month = jan,
	year = {1984},
	doi = {10.31274/rtd-180813-8949},
	file = {(1984) - Open predicate path expressions for distributed environments\: notation, implementation, and extensions - Mark Roger Headington.pdf:/zfiles/documentation/categorized/2 - completely read/Computing/Concurrency/synchronization/path expressions/(1984) - Open predicate path expressions for distributed environments notation, implementation, and extensions - Mark Roger Headington.pdf:application/pdf},
}

@incollection{raynal_lock-based_2013,
	address = {Berlin, Heidelberg},
	title = {Lock-{Based} {Concurrent} {Objects}},
	isbn = {978-3-642-32027-9},
	abstract = {After having introduced the notion of a concurrent object, this chapter presents lock-based methodologies to implement such objects. The first one is based on a low-level synchronization object called a semaphore. The other ones are based on linguistic constructs. One of these constructs is based on an imperative approach (monitor construct), while the other one is based on a declarative approach (path expression construct). This chapter closes the first part of the book devoted to lock-based synchronization.},
	booktitle = {Concurrent {Programming}: {Algorithms}, {Principles}, and {Foundations}},
	publisher = {Springer International Publishing},
	author = {Raynal, Michel},
	year = {2013},
	doi = {10.1007/978-3-642-32027-9_3},
	keywords = {Declarative synchronization, Imperative synchronization, Lock-based implementation, Monitor, Path expression, Predicate transfer, Semaphore},
	pages = {61--109},
	file = {(2013) - Concurrent Programming_ Algorithms, Principles, and Foundations - Michel Raynal (auth.) - (Springer-Verlag Berlin Heidelberg).pdf:/zfiles/documentation/Concurrency/(2013) - Concurrent Programming_ Algorithms, Principles, and Foundations/(2013) - Concurrent Programming_ Algorithms, Principles, and Foundations - Michel Raynal (auth.) - (Springer-Verlag Berlin Heidelberg).pdf:application/pdf},
}

@incollection{campbell_path_2011,
	address = {Boston, MA},
	title = {Path {Expressions}},
	isbn = {978-0-387-09766-4},
	booktitle = {Encyclopedia of {Parallel} {Computing}},
	publisher = {Springer International Publishing},
	author = {Campbell, Roy H.},
	editor = {Padua, David},
	year = {2011},
	doi = {10.1007/978-0-387-09766-4_283},
	pages = {1476--1479},
	file = {(2011) - Encyclopedia of Parallel Computing - David Padua (eds.)-Springer US.pdf:/zfiles/documentation/categorized/1 - partially read/Concurrency/(2011) - Encyclopedia of Parallel Computing - David Padua (eds.)-Springer US.pdf:application/pdf},
}

@inproceedings{govindarajan_parc_1991,
	title = {{ParC} project: practical constructs for parallel programming languages},
	shorttitle = {{ParC} project},
	doi = {10.1109/CMPSAC.1991.170171},
	abstract = {New constructs for synchronization in parallel programming languages are presented for shared memory multiprocessors. The motivation behind the design of these new constructs is to relieve programmers from the burden of imposing synchronization, requiring them only to specify the necessary constraints. Statement tags are introduced. Synchronization is specified by means of regular expressions of statement tags, termed synchronization expressions. Unlike path expressions, the synchronization expressions demand no structural changes on the base language and allow much more complicated synchronization constraints to be expressed and expressed easily. This is due to the use of statement tags and the presence of guards in the latter. Examples are presented to demonstrate the simplicity and the power of synchronization expressions.{\textless}{\textgreater}},
	booktitle = {Proceedings {The} {Fifteenth} {Annual} {International} {Computer} {Software} {Applications} {Conference}},
	author = {Govindarajan, R. and Guo, L. and Yu, S. and Wang, P.},
	month = sep,
	year = {1991},
	keywords = {parallel programming, Concurrent computing, Parallel programming, Programming profession, Computer science, synchronisation, synchronization, Computer languages, multiprocessing systems, Testing, parallel languages, Parallel languages, regular expressions, Councils, Mathematics, parallel programming languages, Art, ParC project, shared memory multiprocessors},
	pages = {183--189},
	file = {(1991) - ParC project. practical constructs for parallel programming languages - Govindarajan, R., Guo, L., Yu, S., & Wang, P. - [1991] Proceedings The Fifteenth Annual.pdf:/zfiles/documentation/categorized/2 - completely read/Computing/Concurrency/synchronization/synchronization expressions/(1991) - ParC project. practical constructs for parallel programming languages - Govindarajan, R., Guo, L., Yu, S., & Wang, P. - [1991] Proceedings The Fifteenth Annual.pdf:application/pdf},
}

@techreport{heinlein_interaction_1997,
	address = {Germany},
	type = {Technical {Report}},
	title = {Interaction {Expressions} -- {A} {Powerful} {Formalism} for {Describing} {Inter}-{Workflow} {Dependencies}},
	shorttitle = {Interaction {Expressions}},
	url = {http://christian.heinleins.net/publ/Heinlein:Ulm.Inf:1997a.pdf},
	institution = {University of Ulm},
	author = {Heinlein, Christian and Dadam, Peter},
	year = {1997},
	file = {(1997) - Interaction Expressions − A Powerful Formalism for Describing Inter-Workflow Dependencies.pdf:/zfiles/documentation/categorized/2 - completely read/Computing/Concurrency/synchronization/interaction expressions/(1997) - Interaction Expressions − A Powerful Formalism for Describing Inter-Workflow Dependencies.pdf:application/pdf},
}

@inproceedings{heinlein_advanced_2003,
	address = {Berlin, Heidelberg},
	title = {Advanced {Thread} {Synchronization} in {Java} {Using} {Interaction} {Expressions}},
	isbn = {978-3-540-36557-0},
	doi = {10.1007/3-540-36557-5_25},
	abstract = {Thread synchronization in Java using synchronized methods or statements is simple and straightforward as long as mutual exclusion of threads is sufficient for an application. Things become less straightforward when wait() andnotify() have to be employed to realize more flexible synchronization schemes. Using two well-known examples, the bounded buffer and the readers and writers problem, the traps and snares of hand-coded synchronization code and its entanglement with the actual application code are illustrated. Following that, interaction expressions are introduced as a completely different approach where synchronization problems are solved in a declarative way by simply specifying permissible execution sequences of methods. Their integration into the Java programming language using a simple precompiler and the basic ideas to enforce at run time the synchronization constraints specified that way are described.},
	booktitle = {Objects, {Components}, {Architectures}, {Services}, and {Applications} for a {Networked} {World}},
	publisher = {Springer Berlin Heidelberg},
	author = {Heinlein, Christian},
	editor = {Aksit, Mehmet and Mezini, Mira and Unland, Rainer},
	year = {2003},
	pages = {345--365},
	file = {(2003) - Objects, Components, Architectures, Services, and Applications for a Networked World, NODe 2002(LNCS2591, Springer)(ISBN 3540007377)(442s).pdf:/zfiles/documentation/categorized/1 - partially read/Computing/Concurrency/Synchronization/expressions/2 - interaction expressions/(2003) - Objects, Components, Architectures, Services, and Applications for a Networked World, NODe 2002(LNCS2591, Springer)(ISBN 3540007377)(442s).pdf:application/pdf},
}

@article{bruin_bcoopl_2000,
	title = {{BCOOPL}: {Basic} {Concurrent} {Object}-{Oriented} {Programming}},
	volume = {30},
	copyright = {Copyright © 2000 John Wiley \& Sons, Ltd},
	issn = {1097-024X},
	doi = {10.1002/(SICI)1097-024X(20000710)30:8<849::AID-SPE318>3.0.CO;2-0},
	number = {8},
	journal = {Software: Practice and Experience},
	author = {Bruin, Hans De},
	year = {2000},
	pages = {849--894},
}

@phdthesis{zhao_sc-expressions_2007,
	address = {Ontario, Canada},
	type = {Ph.{D}. {Thesis}},
	title = {{SC}-{Expressions} in {Object}-{Oriented} {Languages}},
	url = {https://www.bac-lac.gc.ca/eng/services/theses/Pages/item.aspx?idNumber=610558020},
	abstract = {In recent years, parallel computing and object-orientation have played increasingly central roles in information processing and data management. It seems clear that serious consideration should be given to adding support for parallelism in high-level object-oriented programming (OOP) languages, By reviewing both the existing parallelizing compilers and parallel programming languages, we demonstrated the necessity of developing high-level parallel object-oriented programming languages. Synchronization is an essential part of parallel processing. However, the synchronization constructs currently used in parallel programming languages are at too low a level to be compatible with high-level language constructs. More importantly, they are not particularly designed for object-oriented languages. As the main contribution of this thesis, we have designed ' SC-expressions' for specifying synchronization constraints in parallel and OO environments. An SC-expression is a new kind of class member, distinct from properties (data members) and methods (attached function members). SC-expressions specify synchronization constraints for invoking and executing methods in the host object. SC-expressions are designed for ease of use providing programmers the ability to specify synchronization with high-level constructs without worrying about low-level details. In this thesis, we introduce 'process systems, process traces, P-expressions' and their extensions to describe the relationship between concurrent processes based on the "period" view of time. These concepts build the foundations in defining the SC-expression and its languages. The ' languages of SC-expressions' provide us with not only a theoretical model for the semantics of the synchronization constraints in parallel environment but also a systematic approach for implementing SC-expressions based on automata theory.},
	school = {The University of Western Ontario},
	author = {Zhao, Qing},
	year = {2007},
	note = {ISBN: 978-0-494-36770-4},
	file = {(2007) - SC-EXPRESSIONS IN OBJECT - ORIENTED LANGUAGES (Thesis).pdf:/zfiles/documentation/categorized/1 - partially read/Computing/Concurrency/Synchronization/expressions/1 - synchronization expressions/(2007) - SC-EXPRESSIONS IN OBJECT - ORIENTED LANGUAGES (Thesis).pdf:application/pdf},
}

@article{yu_sc-expressions_2007,
	title = {{SC}-{Expressions} in {Object}-{Oriented} {Languages}},
	volume = {18},
	issn = {0129-0541},
	url = {https://www.worldscientific.com/doi/abs/10.1142/S0129054107005479},
	doi = {10.1142/S0129054107005479},
	abstract = {In this paper, SC-expressions are developed, based on automata theory, for specifying synchronization constraints in parallel object-oriented languages. The predecessor of SC-expressions, the synchronization expressions, was introduced in the ParC parallel programming language in the early nineties [19]. However, ParC is not an object-oriented language and also a number of basic features of synchronization expressions are inadequate for object-oriented languages. SC-expressions are developed for object-oriented environment. They are different from synchronization expressions in basic ideas and assumptions. Here we describe the basic ideas of SC-expressions and their applications in object-oriented languages. We also study the problem of inheritance of the SC-expressions.},
	number = {06},
	journal = {International Journal of Foundations of Computer Science},
	author = {Yu, Sheng and Zhao, Qing},
	month = dec,
	year = {2007},
	note = {Publisher: World Scientific Publishing Co.},
	pages = {1441--1452},
	file = {(2007) - SC-EXPRESSIONS IN OBJECT - ORIENTED LANGUAGES - SHENG YU and QING ZHAO.pdf:/zfiles/documentation/categorized/1 - partially read/Computing/Concurrency/Synchronization/expressions/1 - synchronization expressions/(2007) - SC-EXPRESSIONS IN OBJECT - ORIENTED LANGUAGES - SHENG YU and QING ZHAO.pdf:application/pdf;Snapshot:/zfiles/Working_on/CB/Zotero/storage/2GTTES94/S0129054107005479.html:text/html},
}

@phdthesis{guo_synchronization_1994,
	address = {Ontario, Canada},
	type = {Ph.{D}. {Thesis}},
	title = {Synchronization {Expressions} {In} {Parallel} {Programming} {Languages}},
	url = {https://ir.lib.uwo.ca/digitizedtheses/2492},
	school = {The University of Western Ontario},
	author = {Guo, Lifu},
	month = dec,
	year = {1994},
	note = {ISBN: 0-315-99255-7},
	file = {:/zfiles/Working_on/CB/Zotero/storage/R78B9RPC/2492.html:text/html},
}

@incollection{salomaa_synchronization_1999,
	address = {Berlin, Heidelberg},
	title = {Synchronization {Expressions}: {Characterization} {Results} and {Implementation}},
	isbn = {978-3-642-60207-8},
	shorttitle = {Synchronization {Expressions}},
	abstract = {SummarySynchronization expressions are defined as restricted regular expressions that specify synchronization constraints between parallel processes and their semantics is defined using the synchronization languages. In this paper we survey results on synchronization languages, in particular, various approaches to obtain a characterization of this language family using closure under a set of rewriting rules. Also, we discuss the use and implementation of synchronization expressions in a programming language designed for a parallel or distributed computing environment.},
	language = {en},
	booktitle = {Jewels are {Forever}: {Contributions} on {Theoretical} {Computer} {Science} in {Honor} of {Arto} {Salomaa}},
	publisher = {Springer},
	author = {Salomaa, Kai and Yu, Sheng},
	editor = {Karhumäki, Juhani and Maurer, Hermann and Păun, Gheorghe and Rozenberg, Grzegorz},
	year = {1999},
	doi = {10.1007/978-3-642-60207-8_5},
	keywords = {Formal Language Theory, Deterministic Finite Automaton, Distribute Computing Environment, Finite Automaton, Regular Language},
	pages = {45--56},
	file = {(1999) - Jewels are Forever Contributions on Theoretical Computer Science in Honor of Arto Salomaa.pdf:/zfiles/documentation/categorized/1 - partially read/Computing/Concurrency/Synchronization/expressions/1 - synchronization expressions/(1999) - Jewels are Forever Contributions on Theoretical Computer Science in Honor of Arto Salomaa.pdf:application/pdf},
}

@inproceedings{van_den_bos_procol_1989,
	address = {New York, NY, USA},
	series = {{OOPSLA} '89},
	title = {{PROCOL}: {A} {Parallel} {Object} {Language} with {Protocols}},
	isbn = {0-89791-333-7},
	url = {https://doi.org/10.1145/74877.74888},
	doi = {10.1145/74877.74888},
	abstract = {PROCOL is a parallel C-based object-oriented language with communication based on one-way synchronous messages. Objects execute in parallel unless engaged in communication. Communication partners are defined by object instance identifiers, or by type. Therefore send-receive mappings may be 1-1, n-1, or 1-n, though only 1 message is transferred. PROCOL controls object access by a novel concept: an explicit per-object protocol. This protocol is a specification of the occurrence and sequencing of the communication between the object and its partners. Thus protocols support structured, safer and potentially verifiable information exchange between objects. Protocols also act as a composition rule over client objects, thereby offering a 'part-of' hierarchy of these cooperating objects.},
	booktitle = {Conference {Proceedings} on {Object}-{Oriented} {Programming} {Systems}, {Languages} and {Applications}},
	publisher = {Association for Computing Machinery},
	author = {Van Den Bos, J. and Laffra, C.},
	year = {1989},
	note = {event-place: New Orleans, Louisiana, USA},
	pages = {95--102},
}
